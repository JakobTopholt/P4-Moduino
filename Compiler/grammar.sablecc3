Package Moduino;

Helpers

    all = [0 .. 0xFFFF];
    lowercase = ['a' .. 'z'];
    uppercase = ['A' .. 'Z'];
    digit = ['0' .. '9'];
    hex_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];

    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf; // This takes care of different platforms

    not_cr_lf = [all - [cr + lf]];
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];

    blank = (' ' | tab | eol)+;

    short_comment = '//' not_cr_lf* eol;
    long_comment =
        '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
    comment = short_comment | long_comment;

    letter = lowercase | uppercase | '_' | '$';
    id_part = lowercase (lowercase | digit)*;

Tokens

    prog = 'Prog';

    l_bkt = '[';
    r_bkt = ']';
    l_par = '(';
    r_par = ')';
    l_brace =  '{';
    r_brace =  '}';

    plus = '+';
    minus = '-';
    slash = '/';
    star = '*';

    equal = '=';
    q_mark = '?';
    bar = '|';
    arrow = '->';

    comma = ',';
    semicolon = ';';
    colon = ':';

    id = id_part ('_' id_part)*;

    char = ''' not_cr_lf ''';
    number = digit+;
    hex = '0' ('x' | 'X') hex_digit+;

    string = ''' [not_cr_lf - ''']+ ''';

    blank = blank;
    comment = comment;


Ignored Tokens

    blank,
    comment;

Productions

    grammar = prog l_brace stmt_list r_brace {-> New grammar ([stmt_list.exp])};
    stmt_list {-> exp*} = {list} stmt semicolon stmt_list {-> [stmt.exp, stmt_list.exp]} 
                       | {single} stmt {-> [stmt.exp]};
    stmt {-> exp} = exp {-> exp};

     
    exp {-> exp} = {plus} exp plus factor {-> New exp.plus (exp.exp, factor.exp) }
                 | {minus} exp minus factor {-> New exp.minus (exp.exp, factor.exp) }
                 | {factor} factor {-> factor.exp };

    factor {-> exp} = {mult} factor star term {-> New exp.mult (factor.exp, term.exp) }
                    | {div} factor slash term {-> New exp.div (factor.exp, term.exp) }
                    | {term} term {-> term.exp };

    term {-> exp} = {expr} l_par exp r_par {-> exp.exp }
                  | {number} number {-> New exp.number(number) };

Abstract Syntax Tree
    grammar = exp+;
    stmt = exp;
    exp = {plus}    [l]:exp  [r]:exp 
        | {minus}   [l]:exp  [r]:exp 
        | {div}     [l]:exp  [r]:exp 
        | {mult}    [l]:exp  [r]:exp 
        | {number}  number;